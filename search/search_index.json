{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"regenie regenie is a C++ program for generalized linear modelling of large genome-wide association studies . It is developed and supported by a team of scientists at the Regeneron Genetics Center . The method has the following properties It works on quantitative and binary traits, including binary traits with unbalanced case-control ratios It can process multiple phenotypes at once It is fast and memory efficient \ud83d\udd25 For binary traits it supports Firth logistic regression and an SPA test It supports the BGEN and PLINK bed/bim/fam genetic data formats It is ideally suited for implementation in Apache Spark . Citation J. Mbatchou, L. Barnard, J. Backman, A. Marcketta, J. A. Kosmicki, A. Ziyatdinov, C. Benner, C. O'Dushlaine, M. Barber, B. Boutkov, L. Habegger, M. Ferreira, J. Reid, G. Abecasis, E. Maxwell, J. Marchini. (2020) Computationally efficient whole genome regression for quantitative and binary traits [BioRxiv pre-print] License regenie is distributed under an MIT license . Contact If you have any questions about regenie please contact : @marchini If you want to submit a issue concerning the software please do so using the regenie Github repository . Version history Version 1.0 (1 May 2020): Initial release","title":"Home"},{"location":"#regenie","text":"regenie is a C++ program for generalized linear modelling of large genome-wide association studies . It is developed and supported by a team of scientists at the Regeneron Genetics Center . The method has the following properties It works on quantitative and binary traits, including binary traits with unbalanced case-control ratios It can process multiple phenotypes at once It is fast and memory efficient \ud83d\udd25 For binary traits it supports Firth logistic regression and an SPA test It supports the BGEN and PLINK bed/bim/fam genetic data formats It is ideally suited for implementation in Apache Spark . Citation J. Mbatchou, L. Barnard, J. Backman, A. Marcketta, J. A. Kosmicki, A. Ziyatdinov, C. Benner, C. O'Dushlaine, M. Barber, B. Boutkov, L. Habegger, M. Ferreira, J. Reid, G. Abecasis, E. Maxwell, J. Marchini. (2020) Computationally efficient whole genome regression for quantitative and binary traits [BioRxiv pre-print]","title":"regenie"},{"location":"#license","text":"regenie is distributed under an MIT license .","title":"License"},{"location":"#contact","text":"If you have any questions about regenie please contact : @marchini If you want to submit a issue concerning the software please do so using the regenie Github repository .","title":"Contact"},{"location":"#version-history","text":"Version 1.0 (1 May 2020): Initial release","title":"Version history"},{"location":"install/","text":"Download The regenie source code is hosted on Github Installation regenie requires the BGEN library so you will need to download and install that library. In the regenie source code edit the BGEN_PATH variable in the Makefile to the BGEN library path. On the command line type make while in the main source code directory. This should produce the executable called regenie . Computing requirements We have tested regenie on Linux computing environment. Memory usage In both Step 1 and Step 2 of a regenie run the genetic data file is read once, in blocks of SNPs, so at no point is the full dataset ever stored in memory. regenie uses a dimension reduction approach using ridge regression to produce a relatively small set of genetic predictors, that are then used to fit a whole-genome regression model. These genetic predictors are stored in memory by default, and can be relatively large if many phenotypes are stored at once. For example, if there are P phenotypes, M SNPs and N samples, and a block size of B SNPs is used with R ridge parameters, then regenie needs to store roughly N\\times M/B\\times R doubles per phenotype, which is 8Gb per phenotype when M=500,000, N=400,000, B =1,000,R=5 and 200Gb in total when P=25 . However, the --lowmem option can be used to avoid that memory usage, at negligible extra computational cost, by writing temporary files to disk. Threading regenie can take advantage of multiple cores using threading. The number of threads can be specified using the --threads option. regenie uses the Eigen library for efficient linear algebra operations and this uses threading where possible. For PLINK bed/bim/fam files as well as BGEN v1.2 files with 8-bit encoding (format used for UK Biobank 500K imputed data), step 2 of regenie has been optimized by using multithreading through OpenMP .","title":"Install"},{"location":"install/#download","text":"The regenie source code is hosted on Github","title":"Download"},{"location":"install/#installation","text":"regenie requires the BGEN library so you will need to download and install that library. In the regenie source code edit the BGEN_PATH variable in the Makefile to the BGEN library path. On the command line type make while in the main source code directory. This should produce the executable called regenie .","title":"Installation"},{"location":"install/#computing-requirements","text":"We have tested regenie on Linux computing environment.","title":"Computing requirements"},{"location":"install/#memory-usage","text":"In both Step 1 and Step 2 of a regenie run the genetic data file is read once, in blocks of SNPs, so at no point is the full dataset ever stored in memory. regenie uses a dimension reduction approach using ridge regression to produce a relatively small set of genetic predictors, that are then used to fit a whole-genome regression model. These genetic predictors are stored in memory by default, and can be relatively large if many phenotypes are stored at once. For example, if there are P phenotypes, M SNPs and N samples, and a block size of B SNPs is used with R ridge parameters, then regenie needs to store roughly N\\times M/B\\times R doubles per phenotype, which is 8Gb per phenotype when M=500,000, N=400,000, B =1,000,R=5 and 200Gb in total when P=25 . However, the --lowmem option can be used to avoid that memory usage, at negligible extra computational cost, by writing temporary files to disk.","title":"Memory usage"},{"location":"install/#threading","text":"regenie can take advantage of multiple cores using threading. The number of threads can be specified using the --threads option. regenie uses the Eigen library for efficient linear algebra operations and this uses threading where possible. For PLINK bed/bim/fam files as well as BGEN v1.2 files with 8-bit encoding (format used for UK Biobank 500K imputed data), step 2 of regenie has been optimized by using multithreading through OpenMP .","title":"Threading"},{"location":"options/","text":"Documentation Getting started To run regenie , use the command ./regenie on the command line, followed by options and flags as needed. To get a full list of options use ./regenie --help The directory /examples contains some small example files that are useful when getting started. A test run on a set of binary traits can be achieved by the following 2 commands. In Step 1 the whole genome regression model is fit to the traits, and a set of genomic predictions are produced as output ./regenie \\ --step 1 \\ --bed example/example \\ --exclude example/snplist_rm.txt \\ --c example/covariates.txt \\ --p example/phenotype_bin.txt \\ --remove example/fid_iid_to_remove.txt \\ --b 100 \\ --bt --lowmem \\ --o fit_bin_out In Step 2 a set of imputed SNPs are tested for association using a Firth logistic regression model ./regenie \\ --step 2 \\ --bgen example/example.bgen \\ --c example/covariates.txt \\ --p example/phenotype_bin.txt \\ --remove example/fid_iid_to_remove.txt \\ --b 200 \\ --bt \\ --firth 0.01 --approx \\ --pred fit_bin_out_pred.list \\ --split \\ --o test_bin_out_firth One of the output files from this command with association results is included in example/example.test_bin_out_firth_Y1.regenie . Input Option Argument Type Description --bgen, --bed FILE Required Input genetic data file. Either BGEN file eg. file.bgen , or bed/bim/fam prefix that assumes file.bed , file.fam , file.bim exist --sample FILE Optional Sample file corresponding to input BGEN file --remove FILE Optional Exclusion file that lists IDs of individuals to ignore in the analysis --exclude FILE Optional Exclusion file that lists IDs of variants to remove (only works with option --step 1 ) --p FILE Required Phenotypes file --phenoCol STRING Optional Use for each phenotype you want to include in the analysis --c FILE Optional Covariates file --covarCol STRING Optional Use for each covariate you want to include in the analysis --pred FILE Optional File containing predictions from Step 1 (see Overview). This is required for --step 2 Genetic data file format regenie can read BGEN files or bed/bim/fam files in Step 1 and Step 2. The BGEN file format is described here . The bed/bim/fam file format is described here . Tools useful for genetic data file format conversion are : PLINK , QCTOOL , BCFTOOLS . Step 2 of regenie can be sped up with BGEN files by using v1.2 format with 8 bits encoding (genotype file can be generated with PLINK2 using option --export bgen-1.2 'bits=8' ). Sample exclusion file format 2 2 7 7 . No header. Each line starts with individual FID IID. Space separated. Samples listed in this file that are not in bgen/bed file are ignored. Variant exclusion file format 20 31 . No header. Each line must start with variant ID (if there are additional columns, file must be space separated). Variants listed in this file that are not in bgen/bed file are ignored. Covariate file format FID IID V1 V2 V3 1 1 1.46837294454993 1.93779743016325 0.152887004505393 2 2 -1.2234390803815 -1.63408619199948 -0.190201446835255 3 3 0.0711531925667286 0.0863906292357564 0.14254739715665 . Line 1 : Header with FID, IID and C covariate names. Followed by lines of C+2 values. Space separated. Each line contains individual FID and IID followed by C covariate values. Samples listed in this file that are not in bgen/bed file are ignored. Genotyped samples that are not in this file are removed from the analysis. No missing values are allowed. If --step 2 is specified, then the covariate file should be the same as that used in Step 1. Phenotype file format FID IID Y1 Y2 1 1 1.64818554321186 2.2765234736685 2 2 -2.67352013711554 -1.53680421614647 3 3 0.217542851471485 0.437289912695016 . Line 1 : Header with FID, IID and P phenotypes names. Followed by lines of P+2 values. Space separated. Each line contains individual FID and IID followed by P phenotype values (for binary traits, must be coded as 0=control, 1=case, NA=missing). Samples listed in this file that are not in bgen/bed file are ignored. Genotyped samples that are not in this file are removed from the analysis. Missing values must be coded as NA. With QTs, missing values are mean-imputed in Step 1 and they are dropped when testing each phenotype in Step 2 (unless using --force-impute ). With BTs, missing values are mean-imputed in Step 1 when fitting the level 0 linear ridge regression and they are dropped when fitting the level 1 logistic ridge regression for each trait . In Step 2, missing values are dropped when testing each trait. To remove all samples that have missing values at any of the P phenotypes, use option --strict in Step 1 and 2. This is also useful when analyzing a single trait to avoid making a new bed/bgen file just for the complete data set of individuals (so setting the phenotype values of individuals to remove to NA), although --remove can also be used in that situation. Predictions file format Running --step 1 --o foo will produce A set of files containing genomic predictions for each phenotype from Step 1 (see Output section below). A file called foo_pred.list listing the locations of the prediction files. The file list is needed as an input file when using --step 2 via the --pred option. The file list has one line per phenotype (in any order) that specifies the name of the phenotype and its corresponding prediction file name. Each phenotype must have only one prediction file and phenotype names must match with those in the phenotype file. Each prediction file contains the LOCO predictions for the phenotype. Line 1 : FID_IID sample identifier and chromosome number (1-23) Following lines have 24 values representing FID_IID and leave-one chromosome out (LOCO) predictions for each individual. Samples in this file must be in the bed/bgen file and must be included in the analysis (otherwise use --remove ). For each phenotype, samples with missing LOCO predictions must have their corresponding phenotype value set to missing, and all samples with non-missing phenotype values must have LOCO predictions (otherwise use --remove ). Options Option Argument Type Description --step INT Required specify step for the regenie run (see Overview) [argument can be 1 or 2 ] --bt FLAG Optional specify that traits are binary (default is quantitative) --b INT Required size of the genotype blocks --nb INT Optional number of blocks (determined from block size if not provided) --cv INT Optional number of cross validation (CV) folds [default is 5] --loocv FLAG Optional flag to use leave-one out cross validation --lowmem FLAG Optional flag to reduce memory usage by writing level 0 predictions to disk. This is very useful if the number of traits is large (e.g. greater than 10) --strict FLAG Optional flag to removing samples with missing data at any of the phenotypes --ignore-pred FLAG Optional skip reading the file specified by --pred (corresponds to simple linear/logistic regression) --split FLAG Optional flag to split asssociation results into separate files for each trait. --force-impute FLAG Optional flag to keep and impute missing observations for QTs in step 2 --firth FLOAT Optional specify to use Firth likelihood ratio test as fallback for p-values less than the specified threshold [default is 0.05] --approx FLAG Optional flag to use approximate Firth LRT for computational speedup (only works when option --firth is used) --spa FLOAT Optional specify to use Saddlepoint approximation as fallback for p-values less than the specified threshold [default is 0.05] --test STRING Optional specify to carry out dominant or recessive test [default is additive; argument can be dominant or recessive ] --chr INT Optional specify which chromosomes to test in step 2 (use for each chromosome to include) --minMAC INT Optional flag to specify the minimum minor allele count (MAC) when testing variants [default is 5]. Variants with lower MAC are ignored. --niter INT Optional maximum number of iterations for logistic regression [default is 30] --maxstep-null INT Optional maximum step size for logistic model with Firth penalty under the null [default is 25] --threads INT Optional number of computational threads to use [default=all] --debug FLAG Optional debug flag (for use by developers) --v FLAG Optional verbose screen output --help FLAG Optional Prints usage and options list to screen Output Option Argument Type Description --o FILE PREFIX Required Output file that depends on --step A log file file.log of the output is generated. Using --step 1 --o file For the P phenotypes, files file_1.loco ,..., file_P.loco are output with the per-chromosome LOCO predictions as columns of the files. The first row of the files lists FID_IID and the chromosomes output. Genotyped individuals specified using option --remove are excluded from this file. Hence, this can be used if genotype files in step 1 and 2 have different number of samples (so only keeping samples present in both files). Individuals with missing phenotype values kept in the analysis are included in the file and have their predictions set to missing. The list of blup files needed for step 2 (association testing) is written to file_pred.list . Using --step 2 --o file By default, results are written to a single file file.regenie , which has one line per SNP along with a header line. The first 7 entries of each row specify chromosome, posistion, ID, reference allele (allele 0), alternative allele (allele 1), frequency of the alternative allele, and the test performed (additive/dominant/recessive). With BGEN files, the imputation INFO score is also provided. Allele frequency and INFO score, if applicable, are computed using all individuals included in the analysis (so they are the same for all phenotypes). These are followed by the estimated effect sizes, standard errors, chi-square test statistics and -\\log_{10} p-values for each phenotype. When using option --split , the results are written in separate files for each phenotype file_ phenotype1_name .regenie,...,file_ phenotypeP_name .regenie with the same format.","title":"Documentation"},{"location":"options/#documentation","text":"","title":"Documentation"},{"location":"options/#getting-started","text":"To run regenie , use the command ./regenie on the command line, followed by options and flags as needed. To get a full list of options use ./regenie --help The directory /examples contains some small example files that are useful when getting started. A test run on a set of binary traits can be achieved by the following 2 commands. In Step 1 the whole genome regression model is fit to the traits, and a set of genomic predictions are produced as output ./regenie \\ --step 1 \\ --bed example/example \\ --exclude example/snplist_rm.txt \\ --c example/covariates.txt \\ --p example/phenotype_bin.txt \\ --remove example/fid_iid_to_remove.txt \\ --b 100 \\ --bt --lowmem \\ --o fit_bin_out In Step 2 a set of imputed SNPs are tested for association using a Firth logistic regression model ./regenie \\ --step 2 \\ --bgen example/example.bgen \\ --c example/covariates.txt \\ --p example/phenotype_bin.txt \\ --remove example/fid_iid_to_remove.txt \\ --b 200 \\ --bt \\ --firth 0.01 --approx \\ --pred fit_bin_out_pred.list \\ --split \\ --o test_bin_out_firth One of the output files from this command with association results is included in example/example.test_bin_out_firth_Y1.regenie .","title":"Getting started"},{"location":"options/#input","text":"Option Argument Type Description --bgen, --bed FILE Required Input genetic data file. Either BGEN file eg. file.bgen , or bed/bim/fam prefix that assumes file.bed , file.fam , file.bim exist --sample FILE Optional Sample file corresponding to input BGEN file --remove FILE Optional Exclusion file that lists IDs of individuals to ignore in the analysis --exclude FILE Optional Exclusion file that lists IDs of variants to remove (only works with option --step 1 ) --p FILE Required Phenotypes file --phenoCol STRING Optional Use for each phenotype you want to include in the analysis --c FILE Optional Covariates file --covarCol STRING Optional Use for each covariate you want to include in the analysis --pred FILE Optional File containing predictions from Step 1 (see Overview). This is required for --step 2","title":"Input"},{"location":"options/#genetic-data-file-format","text":"regenie can read BGEN files or bed/bim/fam files in Step 1 and Step 2. The BGEN file format is described here . The bed/bim/fam file format is described here . Tools useful for genetic data file format conversion are : PLINK , QCTOOL , BCFTOOLS . Step 2 of regenie can be sped up with BGEN files by using v1.2 format with 8 bits encoding (genotype file can be generated with PLINK2 using option --export bgen-1.2 'bits=8' ).","title":"Genetic data file format"},{"location":"options/#sample-exclusion-file-format","text":"2 2 7 7 . No header. Each line starts with individual FID IID. Space separated. Samples listed in this file that are not in bgen/bed file are ignored.","title":"Sample exclusion file format"},{"location":"options/#variant-exclusion-file-format","text":"20 31 . No header. Each line must start with variant ID (if there are additional columns, file must be space separated). Variants listed in this file that are not in bgen/bed file are ignored.","title":"Variant exclusion file format"},{"location":"options/#covariate-file-format","text":"FID IID V1 V2 V3 1 1 1.46837294454993 1.93779743016325 0.152887004505393 2 2 -1.2234390803815 -1.63408619199948 -0.190201446835255 3 3 0.0711531925667286 0.0863906292357564 0.14254739715665 . Line 1 : Header with FID, IID and C covariate names. Followed by lines of C+2 values. Space separated. Each line contains individual FID and IID followed by C covariate values. Samples listed in this file that are not in bgen/bed file are ignored. Genotyped samples that are not in this file are removed from the analysis. No missing values are allowed. If --step 2 is specified, then the covariate file should be the same as that used in Step 1.","title":"Covariate file format"},{"location":"options/#phenotype-file-format","text":"FID IID Y1 Y2 1 1 1.64818554321186 2.2765234736685 2 2 -2.67352013711554 -1.53680421614647 3 3 0.217542851471485 0.437289912695016 . Line 1 : Header with FID, IID and P phenotypes names. Followed by lines of P+2 values. Space separated. Each line contains individual FID and IID followed by P phenotype values (for binary traits, must be coded as 0=control, 1=case, NA=missing). Samples listed in this file that are not in bgen/bed file are ignored. Genotyped samples that are not in this file are removed from the analysis. Missing values must be coded as NA. With QTs, missing values are mean-imputed in Step 1 and they are dropped when testing each phenotype in Step 2 (unless using --force-impute ). With BTs, missing values are mean-imputed in Step 1 when fitting the level 0 linear ridge regression and they are dropped when fitting the level 1 logistic ridge regression for each trait . In Step 2, missing values are dropped when testing each trait. To remove all samples that have missing values at any of the P phenotypes, use option --strict in Step 1 and 2. This is also useful when analyzing a single trait to avoid making a new bed/bgen file just for the complete data set of individuals (so setting the phenotype values of individuals to remove to NA), although --remove can also be used in that situation.","title":"Phenotype file format"},{"location":"options/#predictions-file-format","text":"Running --step 1 --o foo will produce A set of files containing genomic predictions for each phenotype from Step 1 (see Output section below). A file called foo_pred.list listing the locations of the prediction files. The file list is needed as an input file when using --step 2 via the --pred option. The file list has one line per phenotype (in any order) that specifies the name of the phenotype and its corresponding prediction file name. Each phenotype must have only one prediction file and phenotype names must match with those in the phenotype file. Each prediction file contains the LOCO predictions for the phenotype. Line 1 : FID_IID sample identifier and chromosome number (1-23) Following lines have 24 values representing FID_IID and leave-one chromosome out (LOCO) predictions for each individual. Samples in this file must be in the bed/bgen file and must be included in the analysis (otherwise use --remove ). For each phenotype, samples with missing LOCO predictions must have their corresponding phenotype value set to missing, and all samples with non-missing phenotype values must have LOCO predictions (otherwise use --remove ).","title":"Predictions file format"},{"location":"options/#options","text":"Option Argument Type Description --step INT Required specify step for the regenie run (see Overview) [argument can be 1 or 2 ] --bt FLAG Optional specify that traits are binary (default is quantitative) --b INT Required size of the genotype blocks --nb INT Optional number of blocks (determined from block size if not provided) --cv INT Optional number of cross validation (CV) folds [default is 5] --loocv FLAG Optional flag to use leave-one out cross validation --lowmem FLAG Optional flag to reduce memory usage by writing level 0 predictions to disk. This is very useful if the number of traits is large (e.g. greater than 10) --strict FLAG Optional flag to removing samples with missing data at any of the phenotypes --ignore-pred FLAG Optional skip reading the file specified by --pred (corresponds to simple linear/logistic regression) --split FLAG Optional flag to split asssociation results into separate files for each trait. --force-impute FLAG Optional flag to keep and impute missing observations for QTs in step 2 --firth FLOAT Optional specify to use Firth likelihood ratio test as fallback for p-values less than the specified threshold [default is 0.05] --approx FLAG Optional flag to use approximate Firth LRT for computational speedup (only works when option --firth is used) --spa FLOAT Optional specify to use Saddlepoint approximation as fallback for p-values less than the specified threshold [default is 0.05] --test STRING Optional specify to carry out dominant or recessive test [default is additive; argument can be dominant or recessive ] --chr INT Optional specify which chromosomes to test in step 2 (use for each chromosome to include) --minMAC INT Optional flag to specify the minimum minor allele count (MAC) when testing variants [default is 5]. Variants with lower MAC are ignored. --niter INT Optional maximum number of iterations for logistic regression [default is 30] --maxstep-null INT Optional maximum step size for logistic model with Firth penalty under the null [default is 25] --threads INT Optional number of computational threads to use [default=all] --debug FLAG Optional debug flag (for use by developers) --v FLAG Optional verbose screen output --help FLAG Optional Prints usage and options list to screen","title":"Options"},{"location":"options/#output","text":"Option Argument Type Description --o FILE PREFIX Required Output file that depends on --step A log file file.log of the output is generated. Using --step 1 --o file For the P phenotypes, files file_1.loco ,..., file_P.loco are output with the per-chromosome LOCO predictions as columns of the files. The first row of the files lists FID_IID and the chromosomes output. Genotyped individuals specified using option --remove are excluded from this file. Hence, this can be used if genotype files in step 1 and 2 have different number of samples (so only keeping samples present in both files). Individuals with missing phenotype values kept in the analysis are included in the file and have their predictions set to missing. The list of blup files needed for step 2 (association testing) is written to file_pred.list . Using --step 2 --o file By default, results are written to a single file file.regenie , which has one line per SNP along with a header line. The first 7 entries of each row specify chromosome, posistion, ID, reference allele (allele 0), alternative allele (allele 1), frequency of the alternative allele, and the test performed (additive/dominant/recessive). With BGEN files, the imputation INFO score is also provided. Allele frequency and INFO score, if applicable, are computed using all individuals included in the analysis (so they are the same for all phenotypes). These are followed by the estimated effect sizes, standard errors, chi-square test statistics and -\\log_{10} p-values for each phenotype. When using option --split , the results are written in separate files for each phenotype file_ phenotype1_name .regenie,...,file_ phenotypeP_name .regenie with the same format.","title":"Output"},{"location":"overview/","text":"Overview This page provides an overview of the models and methods implemented in regenie . regenie carries out genome-wide association tests for both quantitative and binary (case-control) phenotypes. It is designed to handle A large number of samples. For example, it is ideally suited to the UK Biobank dataset with 500,000 samples. A combination of genetic data from a micro-array, imputation and exome sequencing. A large number of either quantitative traits (QTs) or binary (case-control) traits (BTs) Accounting for a set of covariates An overview of the regenie method is provided in the figure below. Essentially, regenie is run in 2 steps: In the first step a subset of genetic markers are used to fit a whole genome regression model that captures a good fraction of the phenotype variance attributable to genetic effects. In the second step, a larger set of genetic markers (e.g. imputed markers) are tested for association with the phenotype conditional upon the prediction from the regression model in Step 1, using a leave one chromosome out (LOCO) scheme, that avoids proximal contamination. Step 1 : Whole genome model In Step 1 a whole genome regression model is fit at a subset of the total set of available genetic markers. These are typically a set of several hundred thousand ( M ) common markers from a micro-array. Ridge regression (level 0) regenie reads in the M markers in blocks of B consecutive markers ( --b option). In each block, a set of ridge regression predictors are calculated for a small range of J shrinkage parameters \\{\\tau_1,\\ldots, \\tau_J\\} (using --l0 option [default is 5]) . For a block of SNPs in a N\\times B matrix X and N\\times 1 phenotype vector Y we calculate J predictors X\\widehat{\\beta}_1 \\ldots, X\\widehat{\\beta}_J where \\widehat{\\beta}_j = (X^TX+\\tau_j I)^{-1}X^T Y The idea behind using a range of shrinkage values is to capture the unknown number and size of truly associated genetic markers within each window. The ridge regression takes account of Linkage disequilibrium (LD) within each block. These predictors are stored in place of the genetic markers in matrix W , providing a large reduction in data size. For example, if M=500,000 and B=1,000 and J=5 shrinkage parameters are used, then the reduced dataset will have JM/B=2,500 predictors. Ridge regression is used in this step for both quantitative and binary traits. Cross-validation (level 1) The predictors generated by the ridge regression step will all be positively correlated with the phenotype. Thus, it is important to account for that correlation when building a whole genome wide regression model. When analyzing a quantitative trait we use a second level of ridge regression on the full set of JM/B predictors in W . This approach is inspired by the method of stacked regressions [1]. We fit the ridge regression for a range of shrinkage parameters ( --l1 option) and choose a single best value using K-fold cross validation scheme. This assesses the predictive performance of the model using held out sets of data, and aims to control any over-fitting induced by using the first level of ridge regression to derive the predictors. In other words, we fit the model Y = W\\alpha + \\epsilon where \\alpha is estimated as \\widehat{\\alpha} = (W^TW + \\phi\\,I)^{-1}W^TY and the parameter \\phi is chosen via K-fold cross-validation. For binary traits, we use a logistic ridge regression model to combine the predictors in W \\text{logit}(p) = \\mu + W\\alpha where p is the probability of being a case and \\mu captures the effects of non-genetic covariates. Genetic predictors and LOCO Once \\alpha has been estimated we can construct the genetic prediction Z = W\\widehat{\\alpha} Also, since each column of the matrix W will be associated with a chromosome we can can also construct a genetic prediction ignoring any one chromosome, by simply ignoring those columns when calculating the prediction. This is known as the Leave One Chromosome Out (LOCO) approach. These LOCO predictions are valuable at Step 2 of regenie when each marker is tested for associated (see below). For binary traits, it is the linear predictor in a logistic regression model using LOCO that is saved, and used as an offset when fitting logistic regression models to test for association. Multiple phenotypes The dimension reduction step using ridge regression can be used very efficiently to model multiple phenotypes at once. The ridge regression equations for a block of SNPs in a N\\times B matrix X and a single phenotype in a N\\times 1 matrix Y take the form \\widehat{\\beta} = AY where A = (X^TX+\\tau I)^{-1}X^T does not depend on Y If instead P phenotypes are stored in columns of a N\\times P matrix Y , then the matrix A can be applied jointly to calculate the matrix of estimates \\widehat{\\beta} = AY , and this can take advantage of parallel linear algebra implementations in the Eigen matrix library. Covariates Covariates, such as age and sex and batch effect variables can be included in the regenie model. For quantitative traits, any covariates are regressed out of phenotypes and genotypes before fitting the model. For binary traits, we fit a null model with only covariates, and use predictions from that model as an offset when fitting the logistic regression model. Step 2 : Association testing In Step 2 a larger set of markers are tested for association with the trait (or traits). As with Step 1, these markers are also read in blocks of B markers, and tested for association. This avoids having to have all markers stored in memory at once. Quantitative traits For quantitative traits, we use a linear regression model for association testing. Covariates are regressed out of the phenotypes and genetic markers. The LOCO predictions from Step 1 are removed from the phenotypes. Linear regression is then used to test association of the residualized phenotype and the genetic marker. Parallel linear algebra operations in the Eigen library are used where possible. Binary traits For binary traits, logistic regression is used to test association of the phenotype and the genetic marker. The logistic regression model includes the LOCO predictions from Step 1 as an offset . Covariates are included in the linear predictor in the usual way. When the case-control ratio is imbalanced, standard association tests don't control Type I error well at rare genetic markers. regenie has two options to handle this Firth logistic regression Standard maximum likelihood estimates are generally biased. The Firth correction [2] removes much of the bias, and results in better calibrated test statistics. The correction involves adding a penalty term to the log-likelihood, \\widetilde{l}(\\theta) = l(\\theta) + {1 \\over 2} \\log I|\\theta| where the penalty term corresponds to the use of Jeffrey's Prior. This prior has the effect of shrinking the effect size towards zero. regenie uses a Firth correction when the p-value from the standard logistic regression test is below a threshold (default 0.05). It also includes a novel, accurate and fast approximate Firth correction which is ~60x faster than the exact Firth correction (see the option --firth ). Saddle point approxiation (SPA) test The SPA test approximates the null distribution of the test statistic by approximating the cumulant generating function of the test statistic, which involves all of the higher order moments [3,4]. This provides a better estimation of the tail probabilities compared to using standard asymptotic theory which relies on the normal approximation and uses only the first two moments of the dsitribution. A tail probability is obtained as \\begin{align*} P&(T < t_{\\text{obs}}) \\approx \\Phi(z), \\text{ where,}\\\\ z &= w + \\frac{1}{w}\\log{\\frac{v}{w}}\\\\ w &= \\text{sign}(\\delta^*)\\sqrt{ 2 [ t_{\\text{obs}}\\, \\delta^* - K(\\delta^*)}],\\, v = \\delta^*\\sqrt{K''(\\delta^*)} \\end{align*} and K(\\delta) is the cumulant generating function of the test statistic and \\delta^* is obtained by using a root-finding algorithm for K'(\\delta)=t_{\\text{obs}} . As this approximation has been found not to work very well for ultra-rare variants, a minimum minor allele count (MAC) is used to filter out these variants before testing (option --minMAC ). Missing Phenotype data With QTs, missing values are mean-imputed in Step 1 and they are dropped when testing each phenotype in Step 2 (unless using --force-impute ). With BTs, missing values are mean-imputed in Step 1 when fitting the level 0 linear ridge regression and they are dropped when fitting the level 1 logistic ridge regression for each trait. In Step 2, missing values are dropped when testing each trait. To remove all samples that have missing values at any of the P phenotypes from the analysis, use option --strict in step 1 and 2. This can also be used when analyzing a single trait to only keep individuals with complete data by setting the phenotype values of individuals to remove to NA. References [1] L. Breiman (1996) Stacked Regressions. Machine Learning, 24, 49-64. [2] D. Firth (1993) Bias reduction of maximum likelihood estimates. Biometrika 80, 27\u201338. [3] R. Butler (2007) Saddlepoint Approximations with Applications. Cambridge University Press. [4] R. Dey et al. (2017) A Fast and Accurate Algorithm to Test for Binary Phenotypes and Its Application to PheWAS.The American Journal of Human Genetics 101, 37\u201349.","title":"Overview"},{"location":"overview/#overview","text":"This page provides an overview of the models and methods implemented in regenie . regenie carries out genome-wide association tests for both quantitative and binary (case-control) phenotypes. It is designed to handle A large number of samples. For example, it is ideally suited to the UK Biobank dataset with 500,000 samples. A combination of genetic data from a micro-array, imputation and exome sequencing. A large number of either quantitative traits (QTs) or binary (case-control) traits (BTs) Accounting for a set of covariates An overview of the regenie method is provided in the figure below. Essentially, regenie is run in 2 steps: In the first step a subset of genetic markers are used to fit a whole genome regression model that captures a good fraction of the phenotype variance attributable to genetic effects. In the second step, a larger set of genetic markers (e.g. imputed markers) are tested for association with the phenotype conditional upon the prediction from the regression model in Step 1, using a leave one chromosome out (LOCO) scheme, that avoids proximal contamination.","title":"Overview"},{"location":"overview/#step-1-whole-genome-model","text":"In Step 1 a whole genome regression model is fit at a subset of the total set of available genetic markers. These are typically a set of several hundred thousand ( M ) common markers from a micro-array.","title":"Step 1 : Whole genome model"},{"location":"overview/#ridge-regression-level-0","text":"regenie reads in the M markers in blocks of B consecutive markers ( --b option). In each block, a set of ridge regression predictors are calculated for a small range of J shrinkage parameters \\{\\tau_1,\\ldots, \\tau_J\\} (using --l0 option [default is 5]) . For a block of SNPs in a N\\times B matrix X and N\\times 1 phenotype vector Y we calculate J predictors X\\widehat{\\beta}_1 \\ldots, X\\widehat{\\beta}_J where \\widehat{\\beta}_j = (X^TX+\\tau_j I)^{-1}X^T Y The idea behind using a range of shrinkage values is to capture the unknown number and size of truly associated genetic markers within each window. The ridge regression takes account of Linkage disequilibrium (LD) within each block. These predictors are stored in place of the genetic markers in matrix W , providing a large reduction in data size. For example, if M=500,000 and B=1,000 and J=5 shrinkage parameters are used, then the reduced dataset will have JM/B=2,500 predictors. Ridge regression is used in this step for both quantitative and binary traits.","title":"Ridge regression (level 0)"},{"location":"overview/#cross-validation-level-1","text":"The predictors generated by the ridge regression step will all be positively correlated with the phenotype. Thus, it is important to account for that correlation when building a whole genome wide regression model. When analyzing a quantitative trait we use a second level of ridge regression on the full set of JM/B predictors in W . This approach is inspired by the method of stacked regressions [1]. We fit the ridge regression for a range of shrinkage parameters ( --l1 option) and choose a single best value using K-fold cross validation scheme. This assesses the predictive performance of the model using held out sets of data, and aims to control any over-fitting induced by using the first level of ridge regression to derive the predictors. In other words, we fit the model Y = W\\alpha + \\epsilon where \\alpha is estimated as \\widehat{\\alpha} = (W^TW + \\phi\\,I)^{-1}W^TY and the parameter \\phi is chosen via K-fold cross-validation. For binary traits, we use a logistic ridge regression model to combine the predictors in W \\text{logit}(p) = \\mu + W\\alpha where p is the probability of being a case and \\mu captures the effects of non-genetic covariates.","title":"Cross-validation (level 1)"},{"location":"overview/#genetic-predictors-and-loco","text":"Once \\alpha has been estimated we can construct the genetic prediction Z = W\\widehat{\\alpha} Also, since each column of the matrix W will be associated with a chromosome we can can also construct a genetic prediction ignoring any one chromosome, by simply ignoring those columns when calculating the prediction. This is known as the Leave One Chromosome Out (LOCO) approach. These LOCO predictions are valuable at Step 2 of regenie when each marker is tested for associated (see below). For binary traits, it is the linear predictor in a logistic regression model using LOCO that is saved, and used as an offset when fitting logistic regression models to test for association.","title":"Genetic predictors and LOCO"},{"location":"overview/#multiple-phenotypes","text":"The dimension reduction step using ridge regression can be used very efficiently to model multiple phenotypes at once. The ridge regression equations for a block of SNPs in a N\\times B matrix X and a single phenotype in a N\\times 1 matrix Y take the form \\widehat{\\beta} = AY where A = (X^TX+\\tau I)^{-1}X^T does not depend on Y If instead P phenotypes are stored in columns of a N\\times P matrix Y , then the matrix A can be applied jointly to calculate the matrix of estimates \\widehat{\\beta} = AY , and this can take advantage of parallel linear algebra implementations in the Eigen matrix library.","title":"Multiple phenotypes"},{"location":"overview/#covariates","text":"Covariates, such as age and sex and batch effect variables can be included in the regenie model. For quantitative traits, any covariates are regressed out of phenotypes and genotypes before fitting the model. For binary traits, we fit a null model with only covariates, and use predictions from that model as an offset when fitting the logistic regression model.","title":"Covariates"},{"location":"overview/#step-2-association-testing","text":"In Step 2 a larger set of markers are tested for association with the trait (or traits). As with Step 1, these markers are also read in blocks of B markers, and tested for association. This avoids having to have all markers stored in memory at once.","title":"Step 2 : Association testing"},{"location":"overview/#quantitative-traits","text":"For quantitative traits, we use a linear regression model for association testing. Covariates are regressed out of the phenotypes and genetic markers. The LOCO predictions from Step 1 are removed from the phenotypes. Linear regression is then used to test association of the residualized phenotype and the genetic marker. Parallel linear algebra operations in the Eigen library are used where possible.","title":"Quantitative traits"},{"location":"overview/#binary-traits","text":"For binary traits, logistic regression is used to test association of the phenotype and the genetic marker. The logistic regression model includes the LOCO predictions from Step 1 as an offset . Covariates are included in the linear predictor in the usual way. When the case-control ratio is imbalanced, standard association tests don't control Type I error well at rare genetic markers. regenie has two options to handle this","title":"Binary traits"},{"location":"overview/#firth-logistic-regression","text":"Standard maximum likelihood estimates are generally biased. The Firth correction [2] removes much of the bias, and results in better calibrated test statistics. The correction involves adding a penalty term to the log-likelihood, \\widetilde{l}(\\theta) = l(\\theta) + {1 \\over 2} \\log I|\\theta| where the penalty term corresponds to the use of Jeffrey's Prior. This prior has the effect of shrinking the effect size towards zero. regenie uses a Firth correction when the p-value from the standard logistic regression test is below a threshold (default 0.05). It also includes a novel, accurate and fast approximate Firth correction which is ~60x faster than the exact Firth correction (see the option --firth ).","title":"Firth logistic regression"},{"location":"overview/#saddle-point-approxiation-spa-test","text":"The SPA test approximates the null distribution of the test statistic by approximating the cumulant generating function of the test statistic, which involves all of the higher order moments [3,4]. This provides a better estimation of the tail probabilities compared to using standard asymptotic theory which relies on the normal approximation and uses only the first two moments of the dsitribution. A tail probability is obtained as \\begin{align*} P&(T < t_{\\text{obs}}) \\approx \\Phi(z), \\text{ where,}\\\\ z &= w + \\frac{1}{w}\\log{\\frac{v}{w}}\\\\ w &= \\text{sign}(\\delta^*)\\sqrt{ 2 [ t_{\\text{obs}}\\, \\delta^* - K(\\delta^*)}],\\, v = \\delta^*\\sqrt{K''(\\delta^*)} \\end{align*} and K(\\delta) is the cumulant generating function of the test statistic and \\delta^* is obtained by using a root-finding algorithm for K'(\\delta)=t_{\\text{obs}} . As this approximation has been found not to work very well for ultra-rare variants, a minimum minor allele count (MAC) is used to filter out these variants before testing (option --minMAC ).","title":"Saddle point approxiation (SPA) test"},{"location":"overview/#missing-phenotype-data","text":"With QTs, missing values are mean-imputed in Step 1 and they are dropped when testing each phenotype in Step 2 (unless using --force-impute ). With BTs, missing values are mean-imputed in Step 1 when fitting the level 0 linear ridge regression and they are dropped when fitting the level 1 logistic ridge regression for each trait. In Step 2, missing values are dropped when testing each trait. To remove all samples that have missing values at any of the P phenotypes from the analysis, use option --strict in step 1 and 2. This can also be used when analyzing a single trait to only keep individuals with complete data by setting the phenotype values of individuals to remove to NA.","title":"Missing Phenotype data"},{"location":"overview/#references","text":"[1] L. Breiman (1996) Stacked Regressions. Machine Learning, 24, 49-64. [2] D. Firth (1993) Bias reduction of maximum likelihood estimates. Biometrika 80, 27\u201338. [3] R. Butler (2007) Saddlepoint Approximations with Applications. Cambridge University Press. [4] R. Dey et al. (2017) A Fast and Accurate Algorithm to Test for Binary Phenotypes and Its Application to PheWAS.The American Journal of Human Genetics 101, 37\u201349.","title":"References"},{"location":"performance/","text":"Performance We assessed the performance of regenie against 3 other programs for GWAS on large cohorts. BOLT-LMM Loh et al. (2015) Nature Genetics 47, 284\u2013290 [Software] SAIGE - Zhou et al. (2018) Nature Genetics 50, 1335\u20131341 [Software] fastGWA - Jiang et al. (2019) Nature Genetics 51, 1749\u20131755 [Software] Full details for all the runs are available in the BioRxiv paper (see Home). Quantitative traits We ran regenie , BOLT-LMM and fastGWA on 3 quantitative phenotypes measured on white British UK Biobank participants (LDL, N=389,189; Body mass index [BMI], N=407,609; and Bilirubin, N=388,303) where testing was performed on 9.8 million imputed SNPs. The Manhattan plots for all three phenotypes (see below) show good agreement between the methods with both regenie and BOLT-LMM resulting in stronger association signals relative to fastGWA at known peaks of association (note that in the plots, the scaling of the y-axis changes above the upper dashed line). We assessed the computational requirements of all three methods using a larger set of 50 quantitative traits from the UK Biobank, looking at computational timings as well as memory usage. For regenie and BOLT LMM, 469,336 LD-pruned SNPs were used as model SNPs when fitting the null model (step 1) and for fastGWA, these SNPs were used to compute the sparse GRM (timing not included). Tests were performed on 11.4M imputed SNPs (step 2). From the table above, regenie was 151x faster than BOLT-LMM in elapsed time for Step 1 and 11.5x faster for Step 2, which translated into $ $30x overall speed-up in terms of elapsed time. In addition, regenie had a maximum memory usage of 12.9 GB, which is mostly due to regenie only reading a small portion of the genotype data at a time, whereas BOLT-LMM required 50GB. regenie was 2.8x faster than fastGWA, but fastGWA is very memory efficient and used only a maximum of 2GB. Binary traits regenie was compared to BOLT-LMM and SAIGE on a set of four binary traits measured on white British UK Biobank participants (coronary artery disease [CAD], N=352,063, case-control ratio=1:11; glaucoma, N=406,927, case-control ratio=1:52; colorectal cancer, N=407,746, case-control ratio=1:97; and thyroid cancer, N=407,746, case-control ratio=1:660) and Step 2 testing was performed on 11.6 million imputed SNPs. A novel and fast approximate Firth correction was used in regenie as well as a SPA correction. As seen in the Manhattan plots below (note that the scaling of the y-axis changes above the upper dashed line), all four approaches show very good agreement for the most balanced trait (CAD; case-control ratio=1:11), but as the fraction of cases decreases BOLT-LMM tends to give inflated test statistics. However both regenie with Firth and SPA corrections, as well as SAIGE, which uses SPA correction, are all robust to this inflation and show similar agreement for the associations detected. We assessed the computational requirements of regenie and SAIGE using a larger set of 50 binary traits from the UK Biobank that have a range of different case-control ratios and distinct missing data patterns. 469,336 LD-pruned SNPs were used as model SNPs when fitting the null model (step 1) and tests were performed on 11.4M imputed SNPs (step 2). In step 1, regenie was run using LOOCV and for two traits SAIGE did not finish as it took longer than the 4-week limit. In step 2, the approximate Firth correction was used in regenie in addition to SPA correction. From the table above, Step 1 of regenie was about 350x faster and required only $40\\%$ of the memory used by SAIGE. In Step 2, regenie Firth and SPA were 2x and 3x faster than SAIGE in CPU time, respectively, but were 21x and 34x faster than SAIGE in elapsed time, respectively, which suggests that regenie makes better use of parallelization in this step. Overall, regenie using Firth correction was 8x faster than SAIGE in CPU hours and 26.8x faster in elapsed time. All runs above were done on the same computing environment (16 virtual CPU cores of a 2.1GHz AMD EPYC 7571 processor, 64GB of memory, and 600GB solid-state disk).","title":"Performance"},{"location":"performance/#performance","text":"We assessed the performance of regenie against 3 other programs for GWAS on large cohorts. BOLT-LMM Loh et al. (2015) Nature Genetics 47, 284\u2013290 [Software] SAIGE - Zhou et al. (2018) Nature Genetics 50, 1335\u20131341 [Software] fastGWA - Jiang et al. (2019) Nature Genetics 51, 1749\u20131755 [Software] Full details for all the runs are available in the BioRxiv paper (see Home).","title":"Performance"},{"location":"performance/#quantitative-traits","text":"We ran regenie , BOLT-LMM and fastGWA on 3 quantitative phenotypes measured on white British UK Biobank participants (LDL, N=389,189; Body mass index [BMI], N=407,609; and Bilirubin, N=388,303) where testing was performed on 9.8 million imputed SNPs. The Manhattan plots for all three phenotypes (see below) show good agreement between the methods with both regenie and BOLT-LMM resulting in stronger association signals relative to fastGWA at known peaks of association (note that in the plots, the scaling of the y-axis changes above the upper dashed line). We assessed the computational requirements of all three methods using a larger set of 50 quantitative traits from the UK Biobank, looking at computational timings as well as memory usage. For regenie and BOLT LMM, 469,336 LD-pruned SNPs were used as model SNPs when fitting the null model (step 1) and for fastGWA, these SNPs were used to compute the sparse GRM (timing not included). Tests were performed on 11.4M imputed SNPs (step 2). From the table above, regenie was 151x faster than BOLT-LMM in elapsed time for Step 1 and 11.5x faster for Step 2, which translated into $ $30x overall speed-up in terms of elapsed time. In addition, regenie had a maximum memory usage of 12.9 GB, which is mostly due to regenie only reading a small portion of the genotype data at a time, whereas BOLT-LMM required 50GB. regenie was 2.8x faster than fastGWA, but fastGWA is very memory efficient and used only a maximum of 2GB.","title":"Quantitative traits"},{"location":"performance/#binary-traits","text":"regenie was compared to BOLT-LMM and SAIGE on a set of four binary traits measured on white British UK Biobank participants (coronary artery disease [CAD], N=352,063, case-control ratio=1:11; glaucoma, N=406,927, case-control ratio=1:52; colorectal cancer, N=407,746, case-control ratio=1:97; and thyroid cancer, N=407,746, case-control ratio=1:660) and Step 2 testing was performed on 11.6 million imputed SNPs. A novel and fast approximate Firth correction was used in regenie as well as a SPA correction. As seen in the Manhattan plots below (note that the scaling of the y-axis changes above the upper dashed line), all four approaches show very good agreement for the most balanced trait (CAD; case-control ratio=1:11), but as the fraction of cases decreases BOLT-LMM tends to give inflated test statistics. However both regenie with Firth and SPA corrections, as well as SAIGE, which uses SPA correction, are all robust to this inflation and show similar agreement for the associations detected. We assessed the computational requirements of regenie and SAIGE using a larger set of 50 binary traits from the UK Biobank that have a range of different case-control ratios and distinct missing data patterns. 469,336 LD-pruned SNPs were used as model SNPs when fitting the null model (step 1) and tests were performed on 11.4M imputed SNPs (step 2). In step 1, regenie was run using LOOCV and for two traits SAIGE did not finish as it took longer than the 4-week limit. In step 2, the approximate Firth correction was used in regenie in addition to SPA correction. From the table above, Step 1 of regenie was about 350x faster and required only $40\\%$ of the memory used by SAIGE. In Step 2, regenie Firth and SPA were 2x and 3x faster than SAIGE in CPU time, respectively, but were 21x and 34x faster than SAIGE in elapsed time, respectively, which suggests that regenie makes better use of parallelization in this step. Overall, regenie using Firth correction was 8x faster than SAIGE in CPU hours and 26.8x faster in elapsed time. All runs above were done on the same computing environment (16 virtual CPU cores of a 2.1GHz AMD EPYC 7571 processor, 64GB of memory, and 600GB solid-state disk).","title":"Binary traits"},{"location":"recommendations/","text":"Recommendations for analyzing 500K UK Biobank participants Pre-processing Selection of traits Preparing genotype file Exclusion files Step 1 Step 2","title":"UKBB Analysis"},{"location":"recommendations/#recommendations-for-analyzing-500k-uk-biobank-participants","text":"","title":"Recommendations for analyzing 500K UK Biobank participants"},{"location":"recommendations/#pre-processing","text":"","title":"Pre-processing"},{"location":"recommendations/#selection-of-traits","text":"","title":"Selection of traits"},{"location":"recommendations/#preparing-genotype-file","text":"","title":"Preparing genotype file"},{"location":"recommendations/#exclusion-files","text":"","title":"Exclusion files"},{"location":"recommendations/#step-1","text":"","title":"Step 1"},{"location":"recommendations/#step-2","text":"","title":"Step 2"}]}